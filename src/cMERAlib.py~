#!/usr/bin/env python
import numpy as np
import functools as fct
import warnings
from scipy.sparse.linalg import LinearOperator
from scipy.sparse.linalg import lgmres
import src.cMERAcmpsfunctions as cmf
import math
comm=lambda x,y:np.dot(x,y)-np.dot(y,x)
anticomm=lambda x,y:np.dot(x,y)+np.dot(y,x)
herm=lambda x:np.conj(np.transpose(x))


def toMPOmat(Gamma,dx,eta):
    D=np.shape(Gamma[0][0])[0]
    matrix=np.zeros((D,D,2,2)).astype(Gamma[0][0].dtype)
    matrix[:,:,0,0]=(np.eye(D)+dx*Gamma[0][0])
    matrix[:,:,0,1]=(np.sqrt(dx)*Gamma[0][1])
    matrix[:,:,1,0]=(np.sqrt(dx)*Gamma[1][0])    
    matrix[:,:,1,1]=Gamma[1][1]-dx*np.diag([0.0,-eta])
    return matrix

def checkWick(lam,Rl):
    Rc=Rl.dot(np.diag(lam))
    wick=0.25*(np.trace(herm(Rc).dot(herm(Rc)))*np.trace(Rc.dot(Rc))+np.trace(herm(Rc).dot(Rc))*np.trace(herm(Rc).dot(Rc)))
    full=np.trace(herm(Rc).dot(herm(Rc)).dot(Rc).dot(Rc))
    return wick,full


def checkWickTheorem(Ql,Rl,r,dx,N):
    dens=np.trace(Rl.dot(r).dot(herm(Rl)))
    cdag_c=cmf.HomogeneousLiebLinigerCdagC(Ql,Rl,r,dx,N)
    c_cdag=np.conj(cdag_c)
    cdag_cdag=cmf.HomogeneousLiebLinigerCdagCdag(Ql,Rl,r,dx,N)
    c_c=np.conj(cdag_cdag)
    nn=cmf.HomogeneousLiebLinigerNN(Ql,Rl,r,dx,N)

    return nn-(cdag_cdag*c_c+dens**2+cdag_c*c_cdag)

def alpha(s,k):
    return np.sqrt((1+math.exp(2.0*s)*k**2)/(math.exp(2.0*s)*(1+k**2)))
    

def FreeBosonPiPiCorrelatorExact(scale,t0=-1000,dt=0.001):
    """
    calculate the Pi-Pi correlation function at scale "scale",
    for a state obtained from evolving an initial product state with
    UV cutoff 1.0 to a scale "scale".
    scale: float
           the scale at which to calculate the correlator
    
    """
    #Discretize time t
    t=np.arange(t0,-t0,dt)
    #Define function
    f=1.0-alpha(scale,t)
    #Compute Fourier transform by numpy's FFT function
    g=np.fft.fft(f)
    #frequency normalization factor is 2*np.pi/dt
    w = np.fft.fftfreq(f.size)*2*np.pi/dt
    #In order to get a discretisation of the continuous Fourier transform
    #we need to multiply g by a phase factor
    g*=dt*np.exp(-complex(0,1)*w*t0)/(4*math.pi)
    pipiexact=g[w>=0]
    xexact=w[w>=0]
    return xexact,pipiexact

def FreeBosonPartialPhi_PartialPhiCorrelatorExact(steps,delta):
    #Discretize time t
    t0=-1000.
    dt=0.001
    t=np.arange(t0,-t0,dt)
    #Define function
    s=np.abs(delta)*steps
    f=t**2/alpha(s,t)
    #Compute Fourier transform by numpy's FFT function
    g=np.fft.fft(f)
    #frequency normalization factor is 2*np.pi/dt
    w = np.fft.fftfreq(f.size)*2*np.pi/dt
    #In order to get a discretisation of the continuous Fourier transform
    #we need to multiply g by a phase factor
    g*=dt*np.exp(-complex(0,1)*w*t0)/(2*math.pi)
    partialphipartialphiexact=g[w>=0]
    xexact=w[w>=0]
    return xexact,partialphipartialphiexact
    


#takes an mpo and a time step and creates a propagator mpo ala Zaletel
def createPropagatorMPO(mpo,delta):
    M=mpo.shape[0]
    d=mpo.shape[2]
    #print(mpo.shape)
    #input()
    mat=np.transpose(mpo,(0,2,1,3))
    mat =np.reshape(mat,(d*M,d*M))
    C=mat[0:d,d:-d]
    D=mat[0:d,-d::]
    A=mat[d:-d,d:-d]
    B=mat[d:-d,-d::]

    prop=np.zeros((D.shape[0]+B.shape[0],D.shape[1]+C.shape[1])).astype(mat.dtype)
    prop[0:D.shape[0],0:D.shape[1]]=np.eye(D.shape[0])+delta*D
    prop[D.shape[0]::,0:D.shape[1]]=np.sqrt(delta)*B
    prop[0:D.shape[0],D.shape[1]::]=np.sqrt(delta)*C
    prop[D.shape[0]::,D.shape[1]::]=A
    #print(np.real(prop))

    out=np.transpose(np.reshape(prop,(M-1,d,M-1,d)),(0,2,1,3))
    #input()
    return out

#takes an propagator mpo and a discretization parameter and returns a cmpo; note that even though 
#dx is finite, the result will be a true cmpo if the input mpo has been passed correctly
#note that Gamma[1][1] can be ignored for all but density-density like interactions
def getcMPO(mpo,dx,ignoreGamma11=True):
    M=mpo.shape[0]
    d=mpo.shape[2]    
    mat=np.reshape(np.transpose(mpo,(2,0,3,1)),(M*d,M*d))
    Gamma=[]
    for d1 in range(d):
        G=[]
        for d2 in range(d):
            if (d1==d2):
                if d1==0:
                    G.append((mat[d1*M:(d1+1)*M,d2*M:(d2+1)*M]-np.eye(M))/dx)
                else:
                    if ignoreGamma11:
                        G.append([None])
                    else:
                        mat=mat[d1*M:(d1+1)*M,d2*M:(d2+1)*M]
                        temp=-(np.diag(np.diag(mat))-np.eye(2))
                        A11=mat+temp
                        G.append(A11)
            else:
                G.append(mat[d1*M:(d1+1)*M,d2*M:(d2+1)*M]/np.sqrt(dx))                
        Gamma.append(G)
        
    return Gamma

    
def fullInteractingBosoncMERA_CMPO(dx,cutoff,Lambda,delta,inter,dtype=complex):
    """
    this is the implementation of 

    exp(delta K) with 
    K=inter*\int_{w,x,y,z} dw dx dy dz phi(w) phi(x) phi(y) phi(z) exp(-Lambda(|w-x|+|x-y|+|y-z|))
    with phi=(b^{\dagger}+b)/sqrt(2*cutoff)

    Parameters:
    dx: float
        discretization parameter (use 0.1)
    cutoff: float 
            the UV cutoff of the state; this is what I call \nu in my notes
            \psi(x)=sqrt(cutoff/2)phi(x)+i/sqrt(2*cutoff)pi(x)
    Lambda: float
            length scale of the exponential interaction
    delta:  complex, with imag(delta)>0
            time step
    inter: float
           interaction strength

    Returns:
    a list containing the cMPO matrices of the propagator exp(delta K)

    """
    cdag=np.zeros((2,2)).astype(dtype)
    c=np.zeros((2,2)).astype(dtype)
    cdag[1,0]=1.0
    c[0,1]=1.0

    ipq=(inter*24.0)**0.25;
    op=np.sqrt(dx)*ipq*(cdag+c)/np.sqrt(2*cutoff)
    interactingMPO=np.zeros((5,5,2,2)).astype(dtype)
    interactingMPO[0,0,:,:]=np.eye(2)

    interactingMPO[0,1,:,:]=op
    interactingMPO[1,1,:,:]=np.eye(2)*(1-dx*Lambda)

    interactingMPO[1,2,:,:]=op
    interactingMPO[2,2,:,:]=np.eye(2)*(1-dx*Lambda)

    interactingMPO[2,3,:,:]=op
    interactingMPO[3,3,:,:]=np.eye(2)*(1-dx*Lambda)
    
    interactingMPO[3,4,:,:]=op
    interactingMPO[4,4,:,:]=np.eye(2)
    
    propaint=createPropagatorMPO(interactingMPO,delta)
    Gammasint=getcMPO(propaint,dx,True) 
    return Gammasint

def PiMPO(dx,cutoff):
    cdag=np.zeros((2,2)).astype(complex)
    c=np.zeros((2,2)).astype(complex)
    cdag[1,0]=1.0
    c[0,1]=1.0
    op=(cdag-c)*1j*np.sqrt(cutoff/2.0)
    MPO=np.zeros((2,2,2,2)).astype(complex)
    MPO[0,0,:,:]=np.eye(2)
    MPO[0,1,:,:]=np.sqrt(dx)*op
    MPO[1,1,:,:]=np.eye(2)
    return getcMPO(MPO,dx,False),MPO

def c_c_c_cInteractingBosoncMERA_CMPO(dx,eta,delta,inter,dtype=complex):
    cdag=np.zeros((2,2)).astype(dtype)
    c=np.zeros((2,2)).astype(dtype)
    cdag[1,0]=1.0
    c[0,1]=1.0

    ipq=(inter/24.0)**0.25;
    op=c
    interactingMPO=np.zeros((5,5,2,2)).astype(dtype)
    interactingMPO[0,0,:,:]=np.eye(2)

    interactingMPO[0,1,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[1,1,:,:]=np.eye(2)*(1-dx*eta)

    interactingMPO[1,2,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[2,2,:,:]=np.eye(2)*(1-dx*eta)

    interactingMPO[2,3,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[3,3,:,:]=np.eye(2)*(1-dx*eta)
    
    interactingMPO[3,4,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[4,4,:,:]=np.eye(2)
    propaint=createPropagatorMPO(interactingMPO,delta)
    Gammasint=getcMPO(propaint,dx,True) 
    return Gammasint

def cd_cd_cd_cdInteractingBosoncMERA_CMPO(dx,eta,delta,inter,dtype=complex):
    cdag=np.zeros((2,2)).astype(dtype)
    c=np.zeros((2,2)).astype(dtype)
    cdag[1,0]=1.0
    c[0,1]=1.0

    ipq=(inter/24.0)**0.25;
    op=cd
    interactingMPO=np.zeros((5,5,2,2)).astype(dtype)
    interactingMPO[0,0,:,:]=np.eye(2)

    interactingMPO[0,1,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[1,1,:,:]=np.eye(2)*(1-dx*eta)

    interactingMPO[1,2,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[2,2,:,:]=np.eye(2)*(1-dx*eta)

    interactingMPO[2,3,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[3,3,:,:]=np.eye(2)*(1-dx*eta)
    
    interactingMPO[3,4,:,:]=np.sqrt(dx)*ipq*op
    interactingMPO[4,4,:,:]=np.eye(2)
    propaint=createPropagatorMPO(interactingMPO,delta)
    Gammasint=getcMPO(propaint,dx,True) 
    return Gammasint


"""
conventions:
the implemented operator is  -1j*alpha/2\int dx dy exp(-cutoff*abs(x-y))*(psi(x)psi(y)-psi*(x)psi*(y)) (and y>x)
for alpha =cutoff/4, this gives the cMERA evolution operator for the free Boson theory with a UV-cutoff=cutoff; 
the full prefactor is in this case -1j*cutoff/8
"""

def freeBosoncMERA_CMPO(cutoff,delta,dtype=complex):

    
    alpha=cutoff/4.0
        
    G00=np.diag([0,-cutoff,-cutoff]).astype(dtype)
    G11=np.diag([0,-cutoff,-cutoff]).astype(dtype)

    G01=np.zeros((3,3)).astype(dtype)
    G01[0,2]=np.sqrt(delta*alpha)*np.exp(-1j*math.pi/4)
    G01[2,0]=np.sqrt(delta*alpha)*np.exp(-1j*math.pi/4)

    G10=np.zeros((3,3)).astype(dtype)
    G10[0,1]=np.sqrt(delta*alpha)*np.exp(-1j*math.pi/4)
    G10[1,0]=-np.sqrt(delta*alpha)*np.exp(-1j*math.pi/4)

    return [[np.copy(G00),np.copy(G01)],[np.copy(G10),np.copy(G11)]]

def interactingBosoncMERA_CMPO(eta,delta,inter,dtype=complex):
    G00=np.diag([0,-eta]).astype(dtype)
    A11=np.eye(2).astype(dtype)
    A11[0,1]=np.sqrt(delta*inter)
    A11[1,0]=np.sqrt(delta*inter)

    G01=np.zeros((2,2)).astype(dtype)
    G10=np.zeros((2,2)).astype(dtype)

    return [[np.copy(G00),np.copy(G01)],[np.copy(G10),np.copy(A11)]]



